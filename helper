#!/bin/bash
#
# Usage: ./helper newconfig|newkey|update|show|expiry|help client-name

# These lines taken from https://stackoverflow.com/a/1638397
# Absolute path to this script, e.g. /home/user/pi/EosRemote/ssl/helper
SCRIPT=$(readlink -f "$0")
# Absolute path this script is in, thus /home/user/pi/EosRemote/ssl
SCRIPTPATH=$(dirname "$SCRIPT")

SSL_DIR="$SCRIPTPATH"

CONF_FILE=-openssl.cnf
CERT_FILE=-cert.pem
KEY_FILE=-key.pem
CSR_FILE=-csr.pem
BACKUP_EXT=.bak

CA_DIR="$SSL_DIR/CA"
CA_CONF="$SSL_DIR/ca$CONF_FILE"
CA_CERT="$SSL_DIR/ca$CERT_FILE"
CA_KEY="$CA_DIR/private/ca$KEY_FILE"

NEW_CONFIG_COMMON_NAME=$(hostname -s)
NEW_CONFIG_LONG_HOSTNAMES=($(hostname -A))
NEW_CONFIG_IPS=($(hostname -I))



usage() {
  echo "Usage: $0 [action] [client-name]"
  echo "       $0 help [action]"
}

help() {
  usage
  echo
  echo "newkey client-name     Creates a new RSA key for the client"
  echo "newconfig client-name  Creates an openssl configuration file for the client"
  echo "update client-name     Creates a new certificate for the client, from the key"
  echo "show client-name       Show the details of the client certificate"
  echo "expiry client-name     Show the expiry date/time of the client certificate"
  echo "help                   Show this help text"
}



file_exists() {
  [[ -e "$1" && -s "$1" ]]
  return $?
}

backup_file() {
  local BACKUP_DIR BACKUP
  BACKUP_DIR=$(dirname "$1")
  BACKUP=$(basename "$1")
  BACKUP="$BACKUP_DIR${BACKUP_DIR:+/}${BACKUP%.*}$BACKUP_EXT"
  echo "$BACKUP"
}


newconfig_usage() {
  usage
}

newconfig_help() {
  help
}

newconfig_client() {
  newconfig "$SSL_DIR/$1$CONF_FILE"
}

newconfig_ca() {
  echo "newconfig CA - not yet functional..."
  # newconfig "$CA_CONF"
}

newconfig() {
  local YN=Y
  echo "Config. file: $1"
  if file_exists "$1"; then
    # Config file exists, and is non-empty
    local BACKUP=$(backup_file "$1")
    if file_exists "$BACKUP"; then
      # Backup config file exists, and is non-empty
      #        |<-----------------------    This is 80 chars long!    ----------------------->|
      echo    "Do you want to backup and replace the existing config file (the existing backup"
      read -p "  file will be lost) (Y/n)? " YN
    else
      # Based on one of the answers here: https://stackoverflow.com/a/27875395
      read -p "Do you want to backup and replace the existing config file (Y/n)? " YN
    fi
  fi
  case ${YN:0:1} in
    y|Y )
      if file_exists "$1"; then
        echo "Moving existing config file to backup: $BACKUP"
        mv "$1" "$BACKUP"
      fi
      echo -n "Writing new config file..."
      cat <<EOT > "$1"
#
# OpenSSL configuration file.
# This is mostly being used for generation of certificate requests.
#
# Based various example configuration files, modified and tweaked
#  by DRT for EosRemote, to use as the configuration file for generating
#  the HTTPS certificate request
#

[req]
default_bits		= 2048
default_md		= sha256
string_mask		= utf8only
req_extensions		= req_ext
prompt			= no
distinguished_name	= d_name

[ req_ext ]
keyUsage		= critical, digitalSignature, keyEncipherment
extendedKeyUsage	= serverAuth
subjectAltName		= @alt_names

[ d_name ]
C			= UK
#ST			= County
#L			= City
O			= EosRemote
OU			= EosRemote LAN Server
CN			= ${NEW_CONFIG_COMMON_NAME}

[ alt_names ]
#email			= eosremote@dave.thwaites.org.uk
EOT
      local i j=1
      if ! [ -z "$NEW_CONFIG_COMMON_NAME" ]; then
        echo "DNS.$((j++))			= ${NEW_CONFIG_COMMON_NAME}" >> "$1"
      fi
      for (( i=0; i<${#NEW_CONFIG_LONG_HOSTNAMES[@]}; i++ )); do
        echo "DNS.$((i+j))			= ${NEW_CONFIG_LONG_HOSTNAMES[$i]}" >> "$1"
      done
      for (( i=0; i<${#NEW_CONFIG_IPS[@]}; i++ )); do
        echo "IP.$((i+1))			= ${NEW_CONFIG_IPS[$i]}" >> "$1"
      done
      echo " done!"
      #     |<-----------------------    This is 80 chars long!    ----------------------->|
      echo
      echo "Note: you should review the config file before generating your CSR, to check it"
      echo " matches your requirements.  In particular, look at the [d_name] and"
      echo " [alt_names] sections."
      ;;
    * )
      echo "Canceled"
      ;;
  esac
}




newkey_usage() {
  usage
}

newkey_help() {
  help
}

newkey_client() {
  newkey "$SSL_DIR/$1$KEY_FILE"
}

newkey_ca() {
  echo "newkey CA - not yet functional..."
  # newkey "$CA_KEY"
}

newkey() {
  local YN=Y
  echo "Key file: $1"
  if file_exists "$1"; then
    # Key file exists, and is non-empty
    local BACKUP=$(backup_file "$1")
    #     |<-----------------------    This is 80 chars long!    ----------------------->|
    echo "Warning: Replacing the existing key file will make any certificate and CSR files"
    echo "  based on that key no longer valid - proceed with caution!"
    if file_exists "$BACKUP"; then
      # Backup key file exists, and is non-empty
      #        |<-----------------------    This is 80 chars long!    ----------------------->|
      echo    "Do you want to backup and replace the existing key file (the existing backup"
      read -p "  file will be lost) (Y/n)? " YN
    else
      # Based on one of the answers here: https://stackoverflow.com/a/27875395
      read -p "Do you want to backup and replace the existing key file (Y/n)? " YN
    fi
  fi
  case ${YN:0:1} in
    y|Y )
      if file_exists "$1"; then
        echo "Moving existing key file to backup: $BACKUP"
        mv "$1" "$BACKUP"
      fi
      echo "Generating new key file:"
      openssl genrsa -out "$1" 2048
      echo "New key file: done!"
      ;;
    * )
      echo "Canceled"
      ;;
  esac
}



update_usage() {
  usage
}

update_help() {
  help
}

update_client() {
  update "$SSL_DIR/$1$KEY_FILE" "$SSL_DIR/$1$CSR_FILE" "$SSL_DIR/$1$CONF_FILE" "$SSL_DIR/$1$CERT_FILE"
}

update_ca() {
  echo "update CA - not yet functional..."
}

update() {
  echo "Create a new Certificate Request with existing Key..."
  openssl req -new -key "$1" -out "$2" -config "$3"
  echo "Use our CA to sign the Certificate Request..."
  # -batch  prevents openssl asking if we want to sign the certificate, and commit
  # -notext prevents the plain text details being included in the pem file
  # -create_serial creates the serial number file if it doesn't exist
  openssl ca -in "$2" -out "$4" -batch -create_serial -config "$CA_CONF"
  echo "...done!"
}



show_usage() {
  usage
}

show_help() {
  help
}

show_client() {
  show "$SSL_DIR/$1$CERT_FILE"
}

show_ca() {
  show "$CA_CERT"
}

show() {
  openssl x509 -in "$1" -noout -text
}



expiry_usage() {
  usage
}

expiry_help() {
  help
}

expiry_client() {
  expiry "$SSL_DIR/$1$CERT_FILE"
}

expiry_ca() {
  expiry "$CA_CERT"
}

expiry() {
  local when=$(openssl x509 -in "$1" -noout -enddate)
  echo "Expiry date/time: ${when:9}"
}



case $1 in
  newConfig|newconfig|new_config)
    case $2 in
      CA|ca|Ca|cA)
        newconfig_ca
        ;;
      help)
        newconfig_help
        ;;
      "")
        newconfig_usage
        exit 1
        ;;
      *)
        newconfig_client "$2"
        ;;
    esac
    ;;
  update)
    case $2 in
      CA|ca|Ca|cA)
        update_ca
        ;;
      help)
        update_help
        ;;
      "")
        update_usage
        exit 1
        ;;
      *)
        update_client "$2"
        ;;
    esac
    ;;
  newKey|newkey|new_key)
    case $2 in
      CA|ca|Ca|cA)
        newkey_ca
        ;;
      help)
        newkey_help
        ;;
      "")
        newkey_usage
        exit 1
        ;;
      *)
        newkey_client "$2"
        ;;
    esac
    ;;
  show)
    case $2 in
      CA|ca|Ca|cA)
        show_ca
        ;;
      help)
        show_help
        ;;
      "")
        show_usage
        exit 1
        ;;
      *)
        show_client "$2"
        ;;
    esac
    ;;
  expiry|enddate)
    case $2 in
      CA|ca|Ca|cA)
        expiry_ca
        ;;
      help)
        expiry_help
        ;;
      "")
        expiry_usage
        exit 1
        ;;
      *)
        expiry_client "$2"
        ;;
    esac
    ;;
  help)
    case $2 in
      update)
        update_help
        ;;
      newKey|newkey|new_key)
        newkey_help
        ;;
      show)
        show_help
        ;;
      expiry|enddate)
        expiry_help
        ;;
      "")
        help
        ;;
      *)
        usage
        exit 1
        ;;
    esac
    ;;
  *)
    usage
    exit 1
    ;;
esac